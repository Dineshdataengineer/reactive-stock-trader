include "application"

http {
  address = ${?HTTP_BIND_ADDRESS}
  port = 9010
}

play.filters.hosts {
  # Requests that are not from one of these hosts will be rejected.
  allowed = [${?ALLOWED_HOST}]
}

cassandra.default {
  ## list the contact points  here
  contact-points = [${?CASSANDRA_CONTACT_POINT}]
  ## override Lagomâ€™s ServiceLocator-based ConfigSessionProvider
  session-provider = akka.persistence.cassandra.ConfigSessionProvider
}

cassandra-journal {
  contact-points = ${cassandra.default.contact-points}
  session-provider = ${cassandra.default.session-provider}
}

cassandra-snapshot-store {
  contact-points = ${cassandra.default.contact-points}
  session-provider = ${cassandra.default.session-provider}
}

lagom.persistence.read-side.cassandra {
  contact-points = ${cassandra.default.contact-points}
  session-provider = ${cassandra.default.session-provider}
}

lagom.broker.kafka {
  # If this is an empty string, then the Lagom service locator lookup will not be done,
  # and the brokers configuration will be used instead.
  service-name = ""

  # The URLs of the Kafka brokers. Separate each URL with a comma.
  # This will be ignored if the service-name configuration is non empty.
  brokers = ${?KAFKA_BROKERS_SERVICE_URL}
}

play.http.secret.key = "unused secret"

# after 60s of unsuccessul attempts to form a cluster, 
# the actor system will shut down
akka.cluster.shutdown-after-unsuccessful-join-seed-nodes = 60s

# exit jvm on actor system termination
# this will allow Kubernetes to restart the pod
lagom.cluster.exit-jvm-when-system-terminated = on

akka.discovery.method = akka-dns

akka.management {
  cluster.bootstrap {
    contact-point-discovery {
      discovery-method = kubernetes-api
      service-name = "reactivestock-broker"
      required-contact-point-nr = 1
    }
  }
}